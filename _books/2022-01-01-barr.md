---
title: "The Problem with Software: Why Smart Engineers Write Bad Code"
excerpt_separator: "<!--more-->"
categories:
  - books
tags:
  - software engineering
  - unit testing
  - computer science
  - best practice
  - agile
---


## Adam Barr


![alt text](/images/book_covers/the_problem_with_software.jpg "Title"){: width="250" }

<!--more-->

> ... most programmers are not properly educated in how to program, and it shows in their code (Barr 2018, 30).

> Modifying existing code is what a professional programmer spends the vast majority of their time doing ... (Barr 2018, 39)

> The notion of experimenting and using the results to inform further steps, building up an engineering process on the work
> of those who have gone before, is almost completely absent from software development (Barr 2018, 40).

> Half your future maintenance costs will be spent relearning the details of your program that you will have forgotten in the
> meantime (Barr 2018, 58).

> ... the amount of time it takes your own code to become foreign to you is depressingly short (Barr 2018, 63).

> A defect is an actual flaw in the code: the mistake that a programmer makes. (...) at some point a peice of memory
> will have the wrong value in it, due to the defect in the code - this is the fault. Finally, this fault will cause
> an error that is noticeable to the user - the failure. (Barr 2018, 100).

> Stroustrup used the terms *derived class* and *base class* instead of *subclass* and *superclass* because he
> thought that they were clearer, with the potential confusion being that a subclass is an expansion of the
> superclass, not the other way around as one would expect from the way the word *subset* is used in
> mathematics. (Barr 2018, 125).

> ... it's hard to know if a design is "good" until the whole program is written and working. There is no reliable
> process, top down or bottom up, to arrive at this situation in a deterministic way, and even if nirvana is
> reached, it is only a temporary respite until the requirements of the program change (Barr 2018, 132).

> ...a lot of the benefits of patterns relate to future extensibility (Barr 2018, 151).

> While they don't guarantee that your code has no defects, unit tests area good way to guard against it getting worse
(Barr 2018, 155).

> Having a strong set of unit tests allows software to be moved to newer systems with much less fear of unintended
consequences (Barr 2018, 155).

> Software architects *should* be able to leverage precedent to design a solution in the abstract, and be able to
> communicate that to any programming team in language that is clear and standardized enough that the team will
> recognize the value of the design, and be able to trust that it will be followed (Barr 2018, 158).

> There is another truth about good design: it often runs counter to design that executes quickly (Barr 2018, 160).

> ... optimizing the performance of an algorithm generally makes it more complicated, not simpler.
Programmers think that design and performance are correlated, such that better design runs faster. In reality, they are
frequently inversely correlated: simpler, more elegant designs run slower, and you improve performance by
complicating your design with special cases (Barr 2018, 165).

> C++ was not the first object-oriented language, but it was the one that popularized the approach, which
allowed design patterns and unit testing to go mainstream (Barr 2018, 185).

> Rather than mimicking the smooth flow of water over a waterfall, the process was beginning to look more like riding
a barrel over one: moments of sheer terror followed by getting crushed in the churn at the end (Barr 2018, 197).

> Scrum focuses aggressively on delivering new functionality to the user as often as possible (Barr 2018, 198).

> Every feature delivered during a sprint is supposed to be ready to ship to a customer on the day
it is completed (Barr 2018, 200).

> Today we have faster hardware, more expressive programming languages, and better debugging tools. But
if you read the old books, it is clear that the fundamental issues have not changed (Barr 2018, 217).

> Much of what has been espoused in software engineering in the last twenty years - Agile development, unit
testing, the debate about errors versus exceptions, and the benefits of different programming languages -
has been presented without any experimental backing (Barr 2018, 229).

> ...top-tier university computer science programs don't have a monopoly on producing competent programmers, and
established software companies don't have any magic techniques for engineering software (Barr 2018, 231).

> A widely used strategy is to give the developers pagers and put them on call to look into issues on a rotating
basis, transforming developers into living exception handlers (Barr 2018, 233).

> The sooner students are disabused of the notion that they know everything they need to know, the sooner they
will become receptive to new ideas (Barr 2018, 241).

> ...internships are primarily extended job interviews as well as advertisements for the company (Barr 2018, 246).

[MIT Press](https://mitpress.mit.edu/books/problem-software)
